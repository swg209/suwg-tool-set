<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿·å®«ç”Ÿæˆå™¨ - AIå·¥å…·é›†</title>
    <meta name="description" content="è¿·å®«ç”Ÿæˆå™¨">
    
    <!-- æ ·å¼æ–‡ä»¶ -->
    <link rel="stylesheet" href="../../shared/css/common.css">
    
    <!-- å·¥å…·ç‰¹å®šæ ·å¼ -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: var(--spacing-lg);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .controls {
            padding: 25px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 12px 16px;
            border-radius: var(--radius-md);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .control-group label {
            font-weight: 600;
            color: #495057;
            min-width: 60px;
        }

        .control-group input,
        .control-group select {
            padding: 6px 10px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .maze-container {
            padding: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px;
            background: #f0f8ff;
        }

        .maze-canvas {
            border: 3px solid var(--text-primary);
            border-radius: 8px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            background: white;
        }

        .maze-info {
            padding: var(--spacing-lg);
            background: #f8f9fa;
            border-top: 2px solid #e9ecef;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .info-card {
            background: white;
            padding: var(--spacing-lg);
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .info-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
        }

        .info-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .algorithm-info {
            padding: var(--spacing-lg);
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            margin: var(--spacing-lg);
            border-radius: 0 8px 8px 0;
        }

        .algorithm-info h4 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .algorithm-info p {
            color: #424242;
            line-height: 1.6;
        }

        .legend {
            padding: var(--spacing-lg);
            background: #f8f9fa;
            border-top: 2px solid #e9ecef;
        }

        .legend h3 {
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }

        .legend-items {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid var(--text-primary);
        }

        .legend-text {
            font-weight: 600;
            color: #495057;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            transition: width 0.3s;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            color: #495057;
            font-weight: 600;
            margin-top: 10px;
        }

        .footer {
            text-align: center;
            padding: var(--spacing-lg);
            background: #f8f9fa;
            color: #6c757d;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .header {
                padding: var(--spacing-lg);
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                padding: var(--spacing-lg);
                gap: 15px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: stretch;
                text-align: center;
            }
            
            .maze-container {
                padding: var(--spacing-lg);
            }
            
            .legend-items {
                gap: 15px;
            }
            
            .info-card {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="tool-container">
        <!-- å·¥å…·å¤´éƒ¨ -->
        <header class="tool-header">
            <div class="tool-header-content">
                <a href="../../index.html" class="back-btn">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M10 4l-4 4 4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    è¿”å›å·¥å…·é›†
                </a>
                
                <div class="tool-title">
                    <h1>è¿·å®«ç”Ÿæˆå™¨</h1>
                    <p class="tool-subtitle">è¿·å®«ç”Ÿæˆå™¨</p>
                </div>
                
                <button class="theme-toggle" id="themeToggle" aria-label="åˆ‡æ¢ä¸»é¢˜">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <circle cx="10" cy="10" r="4" stroke="currentColor" stroke-width="2"/>
                        <path d="M10 2v2M10 16v2M18 10h-2M4 10H2M15.66 4.34l-1.41 1.41M5.75 14.25l-1.41 1.41M15.66 15.66l-1.41-1.41M5.75 5.75L4.34 4.34" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
        </header>

        <!-- å·¥å…·ä¸»å†…å®¹ -->
        <main class="tool-main">
            <div class="tool-card">
                <div class="tool-section">
                    <h2>
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <rect x="3" y="3" width="14" height="14" rx="2" stroke="currentColor" stroke-width="2"/>
                        </svg>
                        å·¥å…·åŠŸèƒ½
                    </h2>
                    
                    
            <div class="tool-card">
                <div class="tool-section">
                    <h2>
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <rect x="3" y="3" width="14" height="14" rx="2" stroke="currentColor" stroke-width="2"/>
                        </svg>
                        è¿·å®«ç”Ÿæˆå™¨
                    </h2>
                    <div class="container">
        <div class="header">
            <h1>ğŸ° è¿·å®«ç”Ÿæˆå™¨</h1>
            <p>ç”Ÿæˆç®€å•çš„æ–¹å½¢è¿·å®«ï¼Œå¹¶å¯é€‰æ‹©æ˜¾ç¤ºè§£å†³æ–¹æ¡ˆè·¯å¾„</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>å®½åº¦:</label>
                <input type="number" id="mazeWidth" min="10" max="50" value="25">
            </div>
            
            <div class="control-group">
                <label>é«˜åº¦:</label>
                <input type="number" id="mazeHeight" min="10" max="50" value="25">
            </div>
            
            <div class="control-group">
                <label>ç®—æ³•:</label>
                <select id="algorithm">
                    <option value="dfs">æ·±åº¦ä¼˜å…ˆæœç´¢</option>
                    <option value="prim">Primç®—æ³•</option>
                    <option value="kruskal">Kruskalç®—æ³•</option>
                    <option value="recursive">é€’å½’åˆ†å‰²</option>
                </select>
            </div>
            
            <button class="btn btn-primary" onclick="generateMaze()">ğŸ¯ ç”Ÿæˆè¿·å®«</button>
            <button class="btn btn-success" onclick="solveMaze()" id="solveBtn" style="display: none;">ğŸ§­ æ˜¾ç¤ºè·¯å¾„</button>
            <button class="btn btn-warning" onclick="clearSolution()" id="clearBtn" style="display: none;">ğŸ§¹ æ¸…é™¤è·¯å¾„</button>
            <button class="btn btn-secondary" onclick="downloadMaze()">ğŸ’¾ ä¸‹è½½å›¾ç‰‡</button>
        </div>

        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText"></div>

        <div class="maze-container">
            <canvas id="mazeCanvas" class="maze-canvas" width="600" height="600"></canvas>
        </div>

        <div class="algorithm-info" id="algorithmInfo">
            <h4>æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)</h4>
            <p>ä»èµ·å§‹ç‚¹å¼€å§‹ï¼Œéšæœºé€‰æ‹©æ–¹å‘æ·±å…¥æ¢ç´¢ï¼Œç›´åˆ°æ— è·¯å¯èµ°æ—¶å›æº¯åˆ°ä¸Šä¸€ä¸ªä½ç½®ï¼Œç»§ç»­æ¢ç´¢å…¶ä»–æ–¹å‘ã€‚è¿™ç§ç®—æ³•ç”Ÿæˆçš„è¿·å®«é€šå¸¸æœ‰å¾ˆé•¿çš„é€šé“å’Œè¾ƒå°‘çš„åˆ†æ”¯ã€‚</p>
        </div>

        <div class="maze-info">
            <div class="info-card">
                <div class="info-title">è¿·å®«å¤§å°</div>
                <div class="info-value" id="mazeSize">25 Ã— 25</div>
            </div>
            <div class="info-card">
                <div class="info-title">æ€»é€šé“æ•°</div>
                <div class="info-value" id="pathCount">0</div>
            </div>
            <div class="info-card">
                <div class="info-title">ç”Ÿæˆæ—¶é—´</div>
                <div class="info-value" id="generationTime">0ms</div>
            </div>
            <div class="info-card">
                <div class="info-title">è§£ç­”æ­¥æ•°</div>
                <div class="info-value" id="solutionSteps">-</div>
            </div>
        </div>

        <div class="legend">
            <h3>ğŸ—ºï¸ å›¾ä¾‹</h3>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2c3e50;"></div>
                    <span class="legend-text">å¢™å£</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: white;"></div>
                    <span class="legend-text">é€šé“</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #27ae60;"></div>
                    <span class="legend-text">èµ·ç‚¹</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e74c3c;"></div>
                    <span class="legend-text">ç»ˆç‚¹</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f39c12;"></div>
                    <span class="legend-text">è§£ç­”è·¯å¾„</span>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>ğŸ’¡ æ”¯æŒå¤šç§è¿·å®«ç”Ÿæˆç®—æ³•ï¼Œå¯ä»¥æ˜¾ç¤ºæœ€çŸ­è·¯å¾„è§£ç­”</p>
            <p>è„šæ³¨ï¼šå°è‹è¶£ç ”AI - è®©è¿·å®«ç”Ÿæˆå˜å¾—ç®€å•æœ‰è¶£</p>
        </div>
    </div>

    
                </div>
            </div>
                    <!-- ç»“æœæ˜¾ç¤ºåŒºåŸŸ -->
                    <div class="result-display" id="result">
                        <pre id="resultContent">å¤„ç†ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º...</pre>
                    </div>
                </div>
            </div>
        </main>

        <!-- å·¥å…·é¡µè„š -->
        <footer class="tool-footer">
            <p>ç”± <a href="../../index.html">AIå·¥å…·é›†</a> æä¾› | åŸåˆ›å·¥å…·</p>
        </footer>
    </div>

    <!-- JavaScript -->
    <script src="../../shared/js/utils.js"></script>
    <script>
        // å·¥å…·ç‰¹å®šçš„JavaScriptä»£ç 
        class ToolApp {
            constructor() {
                this.init();
            }

            init() {
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('processBtn').addEventListener('click', () => this.process());
                document.getElementById('clearBtn').addEventListener('click', () => this.clear());
                document.getElementById('copyBtn').addEventListener('click', () => this.copyResult());
                
                // å®æ—¶å¤„ç†ï¼ˆå¯é€‰ï¼‰
                document.getElementById('input').addEventListener('input', 
                    ToolUtils.debounce(() => this.process(), 300)
                );
            }

            process() {
                const input = document.getElementById('input').value;
                const result = this.processInput(input);
                this.displayResult(result);
            }

            processInput(input) {
                
        // è¿·å®«çŠ¶æ€
        let maze = null;
        let solution = null;
        let canvas, ctx;
        let cellSize = 12;

        // ç®—æ³•æè¿°
        const algorithmDescriptions = {
            dfs: {
                title: "æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)",
                description: "ä»èµ·å§‹ç‚¹å¼€å§‹ï¼Œéšæœºé€‰æ‹©æ–¹å‘æ·±å…¥æ¢ç´¢ï¼Œç›´åˆ°æ— è·¯å¯èµ°æ—¶å›æº¯åˆ°ä¸Šä¸€ä¸ªä½ç½®ï¼Œç»§ç»­æ¢ç´¢å…¶ä»–æ–¹å‘ã€‚è¿™ç§ç®—æ³•ç”Ÿæˆçš„è¿·å®«é€šå¸¸æœ‰å¾ˆé•¿çš„é€šé“å’Œè¾ƒå°‘çš„åˆ†æ”¯ã€‚"
            },
            prim: {
                title: "Primç®—æ³•",
                description: "åŸºäºæœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•ã€‚ä»ä¸€ä¸ªèµ·å§‹ç‚¹å¼€å§‹ï¼Œé€æ­¥æ·»åŠ ä¸å½“å‰è¿·å®«ç›¸é‚»çš„å¢™å£ï¼Œç„¶åéšæœºé€‰æ‹©ä¸€é¢å¢™ç§»é™¤ï¼Œå½¢æˆé€šé“ã€‚ç”Ÿæˆçš„è¿·å®«é€šå¸¸åˆ†æ”¯è¾ƒå¤šï¼Œç»“æ„ç›¸å¯¹å¹³è¡¡ã€‚"
            },
            kruskal: {
                title: "Kruskalç®—æ³•",
                description: "å¦ä¸€ç§åŸºäºæœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•ã€‚å°†æ‰€æœ‰å•å…ƒæ ¼çœ‹ä½œç‹¬ç«‹çš„é›†åˆï¼Œéšæœºé€‰æ‹©å¢™å£ï¼Œå¦‚æœå¢™å£ä¸¤ä¾§å±äºä¸åŒé›†åˆåˆ™ç§»é™¤å¢™å£å¹¶åˆå¹¶é›†åˆã€‚ç”Ÿæˆè¾ƒä¸ºéšæœºçš„è¿·å®«ç»“æ„ã€‚"
            },
            recursive: {
                title: "é€’å½’åˆ†å‰²",
                description: "é€’å½’åœ°å°†è¿·å®«åŒºåŸŸåˆ†å‰²æˆæ›´å°çš„åŒºåŸŸï¼Œæ¯æ¬¡åˆ†å‰²æ—¶ç•™ä¸‹ä¸€ä¸ªé€šé“ã€‚è¿™ç§ç®—æ³•ç”Ÿæˆçš„è¿·å®«å…·æœ‰æ˜æ˜¾çš„æˆ¿é—´ç»“æ„ï¼Œé€šé“ç›¸å¯¹è¾ƒå®½ã€‚"
            }
        };

        // åˆå§‹åŒ–
        function init() {
            canvas = document.getElementById('mazeCanvas');
            ctx = canvas.getContext('2d');
            
            // ç›‘å¬ç®—æ³•é€‰æ‹©å˜åŒ–
            document.getElementById('algorithm').addEventListener('change', updateAlgorithmInfo);
            
            // ç›‘å¬å°ºå¯¸å˜åŒ–
            document.getElementById('mazeWidth').addEventListener('change', updateCanvasSize);
            document.getElementById('mazeHeight').addEventListener('change', updateCanvasSize);
            
            updateAlgorithmInfo();
            updateCanvasSize();
        }

        // æ›´æ–°ç®—æ³•ä¿¡æ¯
        function updateAlgorithmInfo() {
            const algorithm = document.getElementById('algorithm').value;
            const info = algorithmDescriptions[algorithm];
            const infoDiv = document.getElementById('algorithmInfo');
            
            infoDiv.innerHTML = `
                <h4>${info.title}</h4>
                <p>${info.description}</p>
            `;
        }

        // æ›´æ–°ç”»å¸ƒå¤§å°
        function updateCanvasSize() {
            const width = parseInt(document.getElementById('mazeWidth').value);
            const height = parseInt(document.getElementById('mazeHeight').value);
            
            // æ ¹æ®è¿·å®«å¤§å°è°ƒæ•´å•å…ƒæ ¼å¤§å°å’Œç”»å¸ƒå¤§å°
            const maxCanvasSize = 600;
            const maxCellSize = Math.min(
                Math.floor(maxCanvasSize / width),
                Math.floor(maxCanvasSize / height)
            );
            
            cellSize = Math.max(4, Math.min(maxCellSize, 20));
            
            canvas.width = width * cellSize;
            canvas.height = height * cellSize;
            
            document.getElementById('mazeSize').textContent = `${width} Ã— ${height}`;
        }

        // ç”Ÿæˆè¿·å®«
        async function generateMaze() {
            const width = parseInt(document.getElementById('mazeWidth').value);
            const height = parseInt(document.getElementById('mazeHeight').value);
            const algorithm = document.getElementById('algorithm').value;
            
            if (width < 5 || height < 5 || width > 100 || height > 100) {
                alert('è¿·å®«å¤§å°åº”åœ¨ 5-100 ä¹‹é—´');
                return;
            }
            
            showProgress('ç”Ÿæˆè¿·å®«ä¸­...', 0);
            const startTime = performance.now();
            
            try {
                maze = await generateMazeByAlgorithm(width, height, algorithm);
                solution = null;
                
                const endTime = performance.now();
                const generationTime = Math.round(endTime - startTime);
                
                document.getElementById('generationTime').textContent = generationTime + 'ms';
                document.getElementById('pathCount').textContent = countPaths();
                document.getElementById('solutionSteps').textContent = '-';
                
                drawMaze();
                
                document.getElementById('solveBtn').style.display = 'inline-block';
                document.getElementById('clearBtn').style.display = 'none';
                
                hideProgress();
                
            } catch (error) {
                console.error('ç”Ÿæˆè¿·å®«å¤±è´¥:', error);
                alert('ç”Ÿæˆè¿·å®«å¤±è´¥ï¼Œè¯·é‡è¯•');
                hideProgress();
            }
        }

        // æ ¹æ®ç®—æ³•ç”Ÿæˆè¿·å®«
        async function generateMazeByAlgorithm(width, height, algorithm) {
            switch (algorithm) {
                case 'dfs':
                    return await generateMazeDFS(width, height);
                case 'prim':
                    return await generateMazePrim(width, height);
                case 'kruskal':
                    return await generateMazeKruskal(width, height);
                case 'recursive':
                    return await generateMazeRecursive(width, height);
                default:
                    throw new Error('æœªçŸ¥ç®—æ³•');
            }
        }

        // æ·±åº¦ä¼˜å…ˆæœç´¢ç”Ÿæˆè¿·å®«
        async function generateMazeDFS(width, height) {
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            const stack = [];
            const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
            
            let currentX = 1, currentY = 1;
            maze[currentY][currentX] = 0;
            stack.push([currentX, currentY]);
            
            let steps = 0;
            const totalSteps = Math.floor((width * height) / 4);
            
            while (stack.length > 0) {
                const neighbors = [];
                
                for (const [dx, dy] of directions) {
                    const newX = currentX + dx;
                    const newY = currentY + dy;
                    
                    if (newX > 0 && newX < width - 1 && newY > 0 && newY < height - 1 && maze[newY][newX] === 1) {
                        neighbors.push([newX, newY, currentX + dx/2, currentY + dy/2]);
                    }
                }
                
                if (neighbors.length > 0) {
                    const [newX, newY, wallX, wallY] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[newY][newX] = 0;
                    maze[wallY][wallX] = 0;
                    stack.push([newX, newY]);
                    currentX = newX;
                    currentY = newY;
                } else {
                    [currentX, currentY] = stack.pop();
                }
                
                steps++;
                if (steps % 10 === 0) {
                    updateProgress(Math.min((steps / totalSteps) * 100, 95));
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            return maze;
        }

        // Primç®—æ³•ç”Ÿæˆè¿·å®«
        async function generateMazePrim(width, height) {
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            const walls = [];
            
            // ä»ä¸­å¿ƒå¼€å§‹
            const startX = 1, startY = 1;
            maze[startY][startX] = 0;
            
            // æ·»åŠ èµ·å§‹ç‚¹çš„å¢™å£
            addWalls(startX, startY, walls, maze, width, height);
            
            let steps = 0;
            const totalSteps = walls.length;
            
            while (walls.length > 0) {
                const randomIndex = Math.floor(Math.random() * walls.length);
                const [x, y, px, py] = walls[randomIndex];
                walls.splice(randomIndex, 1);
                
                if (maze[y][x] === 1) {
                    maze[y][x] = 0;
                    maze[py][px] = 0;
                    addWalls(x, y, walls, maze, width, height);
                }
                
                steps++;
                if (steps % 5 === 0) {
                    updateProgress(Math.min((steps / totalSteps) * 100, 95));
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            return maze;
        }

        // æ·»åŠ å¢™å£åˆ°åˆ—è¡¨
        function addWalls(x, y, walls, maze, width, height) {
            const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
            
            for (const [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;
                const wallX = x + dx/2;
                const wallY = y + dy/2;
                
                if (newX > 0 && newX < width - 1 && newY > 0 && newY < height - 1 && maze[newY][newX] === 1) {
                    walls.push([newX, newY, wallX, wallY]);
                }
            }
        }

        // Kruskalç®—æ³•ç”Ÿæˆè¿·å®«
        async function generateMazeKruskal(width, height) {
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            const sets = new Map();
            const edges = [];
            
            // åˆå§‹åŒ–å•å…ƒæ ¼å’Œè¾¹
            let setId = 0;
            for (let y = 1; y < height; y += 2) {
                for (let x = 1; x < width; x += 2) {
                    maze[y][x] = 0;
                    sets.set(`${x},${y}`, setId++);
                    
                    // æ·»åŠ è¾¹
                    if (x < width - 2) edges.push([x, y, x + 2, y]);
                    if (y < height - 2) edges.push([x, y, x, y + 2]);
                }
            }
            
            // éšæœºæ‰“ä¹±è¾¹
            for (let i = edges.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [edges[i], edges[j]] = [edges[j], edges[i]];
            }
            
            let steps = 0;
            const totalSteps = edges.length;
            
            for (const [x1, y1, x2, y2] of edges) {
                const set1 = sets.get(`${x1},${y1}`);
                const set2 = sets.get(`${x2},${y2}`);
                
                if (set1 !== set2) {
                    // åˆå¹¶é›†åˆ
                    for (const [key, value] of sets) {
                        if (value === set2) {
                            sets.set(key, set1);
                        }
                    }
                    
                    // ç§»é™¤å¢™å£
                    maze[Math.floor((y1 + y2) / 2)][Math.floor((x1 + x2) / 2)] = 0;
                }
                
                steps++;
                if (steps % 10 === 0) {
                    updateProgress(Math.min((steps / totalSteps) * 100, 95));
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            return maze;
        }

        // é€’å½’åˆ†å‰²ç®—æ³•ç”Ÿæˆè¿·å®«
        async function generateMazeRecursive(width, height) {
            const maze = Array(height).fill().map(() => Array(width).fill(0));
            
            // åˆ›å»ºè¾¹ç•Œå¢™
            for (let x = 0; x < width; x++) {
                maze[0][x] = 1;
                maze[height - 1][x] = 1;
            }
            for (let y = 0; y < height; y++) {
                maze[y][0] = 1;
                maze[y][width - 1] = 1;
            }
            
            await recursiveDivision(maze, 1, 1, width - 2, height - 2);
            return maze;
        }

        // é€’å½’åˆ†å‰²è¾…åŠ©å‡½æ•°
        async function recursiveDivision(maze, x, y, width, height) {
            if (width < 2 || height < 2) return;
            
            const horizontal = width < height ? true : (height < width ? false : Math.random() < 0.5);
            
            if (horizontal) {
                const wallY = y + Math.floor(Math.random() * Math.floor(height / 2)) * 2;
                const gapX = x + Math.floor(Math.random() * Math.ceil(width / 2)) * 2;
                
                for (let i = x; i < x + width; i++) {
                    if (i !== gapX) maze[wallY][i] = 1;
                }
                
                await recursiveDivision(maze, x, y, width, wallY - y);
                await recursiveDivision(maze, x, wallY + 1, width, y + height - wallY - 1);
            } else {
                const wallX = x + Math.floor(Math.random() * Math.floor(width / 2)) * 2;
                const gapY = y + Math.floor(Math.random() * Math.ceil(height / 2)) * 2;
                
                for (let i = y; i < y + height; i++) {
                    if (i !== gapY) maze[i][wallX] = 1;
                }
                
                await recursiveDivision(maze, x, y, wallX - x, height);
                await recursiveDivision(maze, wallX + 1, y, x + width - wallX - 1, height);
            }
            
            await new Promise(resolve => setTimeout(resolve, 1));
        }

        // ç»˜åˆ¶è¿·å®«
        function drawMaze() {
            if (!maze) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const height = maze.length;
            const width = maze[0].length;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#2c3e50';
                    } else {
                        ctx.fillStyle = 'white';
                    }
                    
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
            
            // ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
            drawStartEnd();
            
            // ç»˜åˆ¶è§£ç­”è·¯å¾„
            if (solution) {
                drawSolution();
            }
        }

        // ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
        function drawStartEnd() {
            if (!maze) return;
            
            const height = maze.length;
            const width = maze[0].length;
            
            // èµ·ç‚¹ (å·¦ä¸Šè§’ç¬¬ä¸€ä¸ªé€šé“)
            ctx.fillStyle = '#27ae60';
            ctx.fillRect(cellSize, cellSize, cellSize, cellSize);
            
            // ç»ˆç‚¹ (å³ä¸‹è§’æœ€åä¸€ä¸ªé€šé“)
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect((width - 2) * cellSize, (height - 2) * cellSize, cellSize, cellSize);
        }

        // è§£ç­”è¿·å®«
        async function solveMaze() {
            if (!maze) return;
            
            showProgress('æ±‚è§£è¿·å®«ä¸­...', 0);
            
            const startTime = performance.now();
            solution = findPath(maze, 1, 1, maze[0].length - 2, maze.length - 2);
            const endTime = performance.now();
            
            if (solution) {
                document.getElementById('solutionSteps').textContent = solution.length;
                drawMaze();
                document.getElementById('clearBtn').style.display = 'inline-block';
            } else {
                alert('æ— æ³•æ‰¾åˆ°è§£ç­”è·¯å¾„ï¼');
            }
            
            hideProgress();
        }

        // ä½¿ç”¨A*ç®—æ³•å¯»æ‰¾è·¯å¾„
        function findPath(maze, startX, startY, endX, endY) {
            const height = maze.length;
            const width = maze[0].length;
            
            const openSet = [{x: startX, y: startY, g: 0, h: 0, f: 0, parent: null}];
            const closedSet = new Set();
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            
            while (openSet.length > 0) {
                // æ‰¾åˆ°få€¼æœ€å°çš„èŠ‚ç‚¹
                let current = openSet[0];
                let currentIndex = 0;
                
                for (let i = 1; i < openSet.length; i++) {
                    if (openSet[i].f < current.f) {
                        current = openSet[i];
                        currentIndex = i;
                    }
                }
                
                openSet.splice(currentIndex, 1);
                closedSet.add(`${current.x},${current.y}`);
                
                // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                if (current.x === endX && current.y === endY) {
                    const path = [];
                    let node = current;
                    while (node) {
                        path.unshift({x: node.x, y: node.y});
                        node = node.parent;
                    }
                    return path;
                }
                
                // æ£€æŸ¥ç›¸é‚»èŠ‚ç‚¹
                for (const [dx, dy] of directions) {
                    const newX = current.x + dx;
                    const newY = current.y + dy;
                    
                    if (newX < 0 || newX >= width || newY < 0 || newY >= height ||
                        maze[newY][newX] === 1 || closedSet.has(`${newX},${newY}`)) {
                        continue;
                    }
                    
                    const g = current.g + 1;
                    const h = Math.abs(newX - endX) + Math.abs(newY - endY);
                    const f = g + h;
                    
                    // æ£€æŸ¥æ˜¯å¦å·²åœ¨å¼€æ”¾é›†ä¸­
                    const existingIndex = openSet.findIndex(node => node.x === newX && node.y === newY);
                    
                    if (existingIndex === -1) {
                        openSet.push({x: newX, y: newY, g, h, f, parent: current});
                    } else if (g < openSet[existingIndex].g) {
                        openSet[existingIndex] = {x: newX, y: newY, g, h, f, parent: current};
                    }
                }
            }
            
            return null; // æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
        }

        // ç»˜åˆ¶è§£ç­”è·¯å¾„
        function drawSolution() {
            if (!solution) return;
            
            ctx.fillStyle = '#f39c12';
            for (const point of solution) {
                ctx.fillRect(point.x * cellSize, point.y * cellSize, cellSize, cellSize);
            }
            
            // é‡æ–°ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
            drawStartEnd();
        }

        // æ¸…é™¤è§£ç­”è·¯å¾„
        function clearSolution() {
            solution = null;
            drawMaze();
            document.getElementById('clearBtn').style.display = 'none';
            document.getElementById('solutionSteps').textContent = '-';
        }

        // è®¡ç®—é€šé“æ•°é‡
        function countPaths() {
            if (!maze) return 0;
            
            let count = 0;
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[0].length; x++) {
                    if (maze[y][x] === 0) count++;
                }
            }
            return count;
        }

        // æ˜¾ç¤ºè¿›åº¦
        function showProgress(text, progress) {
            document.getElementById('progressBar').style.display = 'block';
            document.getElementById('progressText').textContent = text;
            updateProgress(progress);
        }

        // æ›´æ–°è¿›åº¦
        function updateProgress(progress) {
            document.getElementById('progressFill').style.width = progress + '%';
        }

        // éšè—è¿›åº¦
        function hideProgress() {
            document.getElementById('progressBar').style.display = 'none';
            document.getElementById('progressText').textContent = '';
        }

        // ä¸‹è½½è¿·å®«å›¾ç‰‡
        function downloadMaze() {
            if (!maze) {
                alert('è¯·å…ˆç”Ÿæˆè¿·å®«');
                return;
            }
            
            const link = document.createElement('a');
            link.download = `maze_${maze[0].length}x${maze.length}_${new Date().getTime()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        // åˆå§‹åŒ–åº”ç”¨
        window.addEventListener('load', init);
    
                return input;
            }

            displayResult(result) {
                document.getElementById('resultContent').textContent = result;
            }

            clear() {
                document.getElementById('input').value = '';
                document.getElementById('resultContent').textContent = 'å¤„ç†ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º...';
            }

            copyResult() {
                const result = document.getElementById('resultContent').textContent;
                if (result && result !== 'å¤„ç†ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º...') {
                    ToolUtils.copyToClipboard(result);
                } else {
                    ToolUtils.showToast('æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹', 'warning');
                }
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            new ToolApp();
        });
    </script>
</body>
</html>
